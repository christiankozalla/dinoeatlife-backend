import Hapi from "@hapi/hapi";
import { User, Token, PrismaClient } from "@prisma/client";
import Boom from "@hapi/boom";
import { compare, hash } from "bcryptjs";
import Joi from "joi";

import {
  createAccessToken,
  createRefreshToken,
  verifyRefreshToken,
  RefreshTokenPayload,
  AccessTokenPayload,
  ResponseOnAuth,
  verifyAccessToken
} from "../util/tokens";
import { TokenExpiredError } from "jsonwebtoken";
import { userIsAuthorized } from "../util/authorization";

declare module "@hapi/hapi" {
  interface AuthCredentials {
    email?: User["email"];
    password?: User["password"];
    userId: User["id"];
    homeId: User["homeId"];
  }
  interface ServerApplicationState {
    prisma: PrismaClient;
  }
}

export const authPlugin: Hapi.Plugin<null> = {
  name: "auth",
  dependencies: ["prisma", "hapi-auth-jwt2", "@hapi/basic"],
  register: async function (server: Hapi.Server) {
    if (!process.env.ACCESS_TOKEN_SECRET) {
      server.log(
        "warn",
        "The JWT_SECRET env var is not set. This is unsafe! If running in production, set it."
      );
    }

    // Credentials must be passed via request.headers.authorization
    // Format: Basic <base64 encoded useremail:password>
    // Example: request.headers.authorization = btoa("christian@christian.de:christiansNicePassword");
    server.auth.strategy("authPassword", "basic", { validate: validateUserPassword });

    server.auth.strategy("authJWT", "jwt", {
      key: process.env.ACCESS_TOKEN_SECRET!,
      verifyOptions: { algorithms: ["HS256"] },
      validate: validateAccessToken
    });

    server.auth.default("authJWT");

    // routes
    server.route([
      {
        method: "POST",
        path: "/register",
        options: {
          auth: false,
          validate: {
            payload: Joi.object({
              email: Joi.string().email().required(),
              password: Joi.string().required()
            })
          }
        },
        handler: async (request: Hapi.Request, h: Hapi.ResponseToolkit) => {
          const { prisma } = request.server.app;
          const { email, password } = request.payload as User;

          if (!email || !password) {
            return Boom.badRequest("Credentials missing");
          }

          try {
            const newUser = await prisma.user.create({
              data: {
                email,
                password: await hash(password, 10),
                home: {
                  create: {
                    name: "Default Home Name"
                  }
                }
              }
            });

            if (!newUser) {
              return Boom.badData("Email already exists");
            }

            const credentials: ResponseOnAuth = {
              userId: newUser.id,
              homeId: newUser.homeId,
              accessToken: createAccessToken(newUser.id, newUser.homeId)
            };

            const refreshToken = createRefreshToken(
              { userId: newUser.id, homeId: newUser.homeId },
              request.info.remoteAddress
            );

            const tokenStored = await prisma.token.create({
              data: {
                userId: newUser.id,
                token: refreshToken,
                createdAt: new Date().toISOString(),
                expiresAt: new Date(new Date().setDate(new Date().getDate() + 7)).toISOString() // 7d from now
              }
            });

            if (!tokenStored) {
              return Boom.badImplementation();
            }

            // Store a 24h random 8-digit string as EMAIL_TOKEN
            // User gets property "isVerified" @default(false)
            // Prompt authenticated users eventually for the autogenerated number - when they use the ACCESS_TOKEN

            return h.response(credentials).state("blim", refreshToken).code(201);
          } catch (err) {
            return Boom.badImplementation(err);
          }
        }
      },
      {
        method: "GET",
        path: "/login",
        options: {
          auth: "authPassword"
        },
        handler: async (request: Hapi.Request, h: Hapi.ResponseToolkit) => {
          const { prisma } = request.server.app;
          const { credentials } = request.auth;

          try {
            const userGotToken = await prisma.token.findUnique({
              where: {
                userId: credentials.userId
              }
            });

            if (userGotToken) {
              return h.response(credentials).code(200);
            } else {
              return Boom.conflict();
            }
          } catch (err) {
            return Boom.badImplementation();
          }

          try {
            const refreshToken = createRefreshToken(credentials, request.info.remoteAddress);

            // let storedToken = await prisma.token.upsert({
            //   where: {
            //     userId: credentials.userId
            //   },
            //   select: {
            //     token: true
            //   },
            //   create: {
            //     userId: credentials.userId,
            //     token: refreshToken,
            //     createdAt: new Date().toISOString(),
            //     expiresAt: new Date(new Date().setDate(new Date().getDate() + 7)).toISOString() // 7d from now
            //   },
            //   update: {
            //     userId: credentials.userId,
            //     token: refreshToken,
            //     createdAt: new Date().toISOString(),
            //     expiresAt: new Date(new Date().setDate(new Date().getDate() + 7)).toISOString() // 7d from now
            //   }
            // });

            let storedToken = await prisma.token.create({
              data: {
                userId: credentials.userId,
                token: refreshToken,
                createdAt: new Date().toISOString(),
                expiresAt: new Date(new Date().setDate(new Date().getDate() + 7)).toISOString() // 7d from now
              }
            });

            if (storedToken) {
              return h.response(credentials).state("blim", refreshToken).code(200);
            } else {
              return Boom.conflict();
            }
          } catch (err) {
            return Boom.badImplementation(err);
          }
        }
      },
      {
        method: "GET",
        path: "/refresh",
        options: {
          auth: false,
          state: {
            parse: true,
            failAction: "error"
          }
        },
        handler: async (request: Hapi.Request, h: Hapi.ResponseToolkit) => {
          const { prisma } = request.server.app;
          const refreshToken = request.state.blim;

          // Verify the token
          const decoded = verifyRefreshToken(refreshToken);

          // Check if hosts are the same
          if (decoded && decoded.remoteAddress === request.info.remoteAddress) {
            // Sign a new access token
            const credentials: ResponseOnAuth = {
              userId: decoded.userId,
              homeId: decoded.homeId,
              accessToken: createAccessToken(decoded.userId, decoded.homeId)
            };

            return h.response(credentials).code(200);
          }

          // OR Reject the request if invalid
          // Might wanna delete token - i.e. revoke token and log the user out
          await prisma.token.delete({
            where: {
              userId: decoded.userId
            }
          });
          return Boom.badRequest();
        }
      }
    ]);
  }
};

const validateUserPassword = async (
  request: Hapi.Request,
  username: string,
  password: string,
  h: Hapi.ResponseToolkit
) => {
  const { prisma } = request.server.app;

  try {
    // Fetch user from DB
    const registeredUser = await prisma.user.findUnique({
      where: {
        email: username
      }
    });

    if (!registeredUser) {
      return Boom.notFound("User not found");
    }

    const isValid = await compare(password, registeredUser.password);

    if (!isValid) {
      return { isValid };
    }

    // Passed to request.auth.credentials in route handler
    const credentials: ResponseOnAuth = {
      userId: registeredUser.id,
      homeId: registeredUser.homeId,
      accessToken: createAccessToken(registeredUser.id, registeredUser.homeId)
    };

    return { isValid, credentials };
  } catch (err) {
    return Boom.badImplementation("Error in validateUserPassword");
  }
};

const validateAccessToken = async (
  decoded: AccessTokenPayload,
  request: Hapi.Request,
  h: Hapi.ResponseToolkit
) => {
  const { prisma } = request.server.app;
  const { userId } = decoded;

  //const isValid = verifyAccessToken(decoded);

  request.server.log("info", decoded);

  try {
    // Call to DB not necessary with JWT tokens
    const user = await prisma.user.findUnique({
      where: {
        id: userId
      }
    });

    if (!user) {
      return { isValid: false };
    } else {
      // { userId, homeId } are being passed to request.auth.credentials here
      return { isValid: true };
    }
  } catch (err) {
    return Boom.badImplementation("Error in validateAccessToken");
  }
};

import Hapi from "@hapi/hapi";
import { Home, Profile, User, PrismaClient } from "@prisma/client";
import Boom from "@hapi/boom";
import { compare, hash } from "bcryptjs";
import Joi from "joi";
import mailer from "../util/mailer";

import {
  createAccessToken,
  createRefreshToken,
  verifyRefreshToken,
  createAntiCsrfToken,
  AccessTokenPayload
} from "../util/tokens";

declare module "@hapi/hapi" {
  interface AuthCredentials extends ResponseOnLogin {
    email?: User["email"];
    password?: User["password"];
  }
  interface ServerApplicationState {
    prisma: PrismaClient;
  }
}

interface RegisteringUser {
  email: User["email"];
  password: User["password"];
  name: Profile["name"];
  homeName: Home["name"];
}

interface ResponseOnLogin extends AccessTokenPayload {
  accessToken: string;
}

export const authPlugin: Hapi.Plugin<null> = {
  name: "auth",
  dependencies: ["prisma", "hapi-auth-jwt2", "@hapi/basic"],
  register: async function (server: Hapi.Server) {
    if (!process.env.ACCESS_TOKEN_SECRET) {
      server.log(
        "warn",
        "The JWT_SECRET env var is not set. This is unsafe! If running in production, set it."
      );
    }

    // Credentials must be passed via request.headers.authorization
    // Format: Basic <base64 encoded useremail:password>
    // Example: request.headers.authorization = btoa("christian@christian.de:christiansNicePassword");
    server.auth.strategy("authPassword", "basic", { validate: validateUserPassword });

    server.auth.strategy("authJWT", "jwt", {
      key: process.env.ACCESS_TOKEN_SECRET!,
      verifyOptions: { algorithms: ["HS256"] },
      validate: validateAccessToken
    });

    server.auth.default("authJWT");

    // routes
    server.route([
      {
        method: "POST",
        path: "/register",
        options: {
          auth: false,
          validate: {
            payload: Joi.object({
              email: Joi.string().email().required(),
              password: Joi.string().required(),
              name: Joi.string().required(),
              homeName: Joi.string().required()
            }).label("registeringUser")
          },
          tags: ["api"],
          description: "Creates a new user. Sends Email-Verification"
        },
        handler: async (request: Hapi.Request, h: Hapi.ResponseToolkit) => {
          const { prisma } = request.server.app;
          const { email, password, name, homeName } = request.payload as RegisteringUser;

          if (!email || !password || !name || !homeName) {
            return Boom.badRequest("Credentials missing");
          }

          try {
            const emailToken = generateEmailToken();

            const sent = await mailer.sendVerifyMail({
              userName: name,
              userEmail: email,
              emailToken
            });
            request.server.log("info", sent);

            if (sent) {
              const newUser = await prisma.user.create({
                data: {
                  email,
                  password: await hash(password, 10),
                  home: {
                    create: {
                      name: homeName
                    }
                  },
                  profile: {
                    create: {
                      name
                    }
                  },
                  emailToken: {
                    create: {
                      emailToken
                    }
                  }
                }
              });

              if (!newUser) {
                return Boom.badData("Email already exists");
              }

              const credentials: ResponseOnLogin = {
                userId: newUser.id,
                homeId: newUser.homeId,
                accessToken: createAccessToken(newUser.id, newUser.homeId)
              };

              return h.response(credentials).code(201);
            } else {
              return Boom.badImplementation("Error sending Mail");
            }

            /* Give the user a refresh token once his email is verified! */
            // const refreshToken = createRefreshToken(
            //   { userId: newUser.id, homeId: newUser.homeId },
            //   request.info.remoteAddress
            // );

            // const tokenStored = await prisma.token.create({
            //   data: {
            //     userId: newUser.id,
            //     token: refreshToken,
            //     createdAt: new Date().toISOString(),
            //     expiresAt: new Date(new Date().setDate(new Date().getDate() + 7)).toISOString() // 7d from now
            //   }
            // });

            // if (!tokenStored) {
            //   return Boom.badImplementation();
            // }

            // Store a 24h random 8-digit string as EMAIL_TOKEN
            // User gets property "isVerified" @default(false)
            // Prompt authenticated users eventually for the autogenerated number - when they use the ACCESS_TOKEN
          } catch (err) {
            return Boom.badImplementation(err);
          }
        }
      },
      {
        method: "GET",
        path: "/login",
        options: {
          auth: "authPassword",
          tags: ["api"],
          description:
            "Expects email and password in Authorization header like `Basic btoa(<EMAIL>:<PASSWORD>)`"
        },
        handler: async (request: Hapi.Request, h: Hapi.ResponseToolkit) => {
          const { credentials } = request.auth;

          try {
            if (credentials.accessToken) {
              const refreshToken = createRefreshToken(credentials, request.info.remoteAddress);
              const antiCsrfToken = createAntiCsrfToken();
              return h
                .response(credentials)
                .state("blim", refreshToken)
                .state("anti-csrf", antiCsrfToken)
                .code(200);
            } else {
              return Boom.notFound();
            }
          } catch (err) {
            return Boom.badImplementation(err);
          }
        }
      },
      {
        method: "GET",
        path: "/refresh",
        options: {
          auth: false,
          state: {
            parse: true,
            failAction: "error"
          },
          tags: ["api"]
        },
        handler: async (request: Hapi.Request, h: Hapi.ResponseToolkit) => {
          // const { prisma } = request.server.app;
          const refreshToken: string | null = request.state.blim;

          if (refreshToken) {
            // Verify the token
            const decoded = verifyRefreshToken(refreshToken);

            // Check if hosts are the same
            if (decoded /* && decoded.remoteAddress === request.info.remoteAddress */) {
              // Sign a new access token
              const credentials: ResponseOnLogin = {
                userId: decoded.userId,
                homeId: decoded.homeId,
                accessToken: createAccessToken(decoded.userId, decoded.homeId)
              };

              return h.response(credentials).code(200);
            } else {
              // OR Reject the request if invalid
              // Might wanna delete token - i.e. revoke token and log the user out
              // await prisma.token.delete({
              //   where: {
              //     userId: decoded.userId
              //   }
              // });
              return Boom.badRequest();
            }
          } else {
            // refreshToken === null
            return Boom.badRequest();
          }
        }
      },
      {
        method: "GET",
        path: "/validate",
        options: {
          auth: false, // Would it be good to require the accessToken aswell?
          tags: ["api"]
        },
        handler: async (request: Hapi.Request, h: Hapi.ResponseToolkit) => {
          const { prisma } = request.server.app;
          const { user, emailToken } = request.query;

          if (user && emailToken) {
            // Validate emailToken
            const userEmail = Buffer.from(user, "base64url").toString("utf-8");
            const decodedEmailToken = Buffer.from(emailToken, "base64url").toString("utf-8");

            try {
              // 1. Fetch User + stored emailToken
              const registeredUser = await prisma.user.findUnique({
                where: {
                  email: userEmail
                },
                select: {
                  id: true,
                  email: true,
                  homeId: true,
                  emailToken: true
                }
              });

              if (!registeredUser || !registeredUser.emailToken) {
                return Boom.notFound();
              }

              // 2. Compare emailTokens
              if (registeredUser.emailToken.emailToken !== decodedEmailToken) {
                // 2.a false => delete user email

                // Soft delete - But then handle those cases correctly - always...
                // await prisma.user.update({
                //   where: {
                //     email: userEmail
                //   },
                //   data: {
                //     isDeleted: true
                //   }
                // });

                await prisma.user.update({
                  where: {
                    id: registeredUser.id
                  },
                  data: {
                    token: {
                      delete: true
                    },
                    emailToken: {
                      delete: true
                    },
                    profile: {
                      delete: true
                    }
                  }
                });

                await prisma.user.delete({
                  where: {
                    id: registeredUser.id
                  }
                });

                return Boom.badData();
              } else {
                // 2.b true => send back refreshToken
                const refreshToken = createRefreshToken(
                  { userId: registeredUser.id, homeId: registeredUser.homeId },
                  request.info.remoteAddress
                );

                const credentials: ResponseOnLogin = {
                  userId: registeredUser.id,
                  homeId: registeredUser.homeId,
                  accessToken: createAccessToken(registeredUser.id, registeredUser.homeId)
                };

                await prisma.user.update({
                  where: {
                    email: userEmail
                  },
                  data: {
                    isVerfied: true
                  }
                });

                return h.response(credentials).state("blim", refreshToken).code(200);
              }
            } catch (err) {
              return Boom.badImplementation(err);
            }
          }
        }
      }
    ]);
  }
};

const validateUserPassword = async (
  request: Hapi.Request,
  username: string,
  password: string,
  h: Hapi.ResponseToolkit
) => {
  const { prisma } = request.server.app;

  try {
    // Fetch user from DB
    const registeredUser = await prisma.user.findUnique({
      where: {
        email: username
      }
    });

    if (!registeredUser) {
      return Boom.notFound("User not found");
    }

    const isValid = await compare(password, registeredUser.password);

    if (!isValid) {
      return { isValid };
    }

    // Passed to request.auth.credentials in route handler
    const credentials: ResponseOnLogin = {
      userId: registeredUser.id,
      homeId: registeredUser.homeId,
      accessToken: createAccessToken(registeredUser.id, registeredUser.homeId)
    };

    return { isValid, credentials };
  } catch (err) {
    return Boom.badImplementation("Error in validateUserPassword" + err);
  }
};

const validateAccessToken = async (
  decoded: AccessTokenPayload,
  request: Hapi.Request,
  h: Hapi.ResponseToolkit
) => {
  const { prisma } = request.server.app;
  const { userId } = decoded;

  //const isValid = verifyAccessToken(decoded);
  // decoded cannot be null - hapi-auth-jwt2 throws an exception ealier if token malformed, expired, something else

  try {
    // Call to DB not necessary with JWT tokens
    const user = await prisma.user.findUnique({
      where: {
        id: userId
      }
    });

    if (!user) {
      return { isValid: false };
    } else {
      // { userId, homeId } are being passed to request.auth.credentials here
      return { isValid: true };
    }
  } catch (err) {
    return Boom.badImplementation("Error in validateAccessToken" + err);
  }
};

const generateEmailToken = () => {
  return Math.random().toString(36).substr(2, 9);
};
